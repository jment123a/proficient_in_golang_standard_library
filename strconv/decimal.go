// 版权所有2009 The Go Authors。 版权所有。
// 此源代码的使用受BSD样式的约束
// 可以在LICENSE文件中找到的许可证。

// 多精度十进制数字。
// 仅用于浮点格式； 不是通用的。
// 仅分配操作和（二进制）左/右移位。
// 由于2除以10，因此可以精确地执行多精度十进制的二进制浮点； 不能精确地在多精度二进制中执行十进制浮点运算。

package strconv

type decimal struct {
	d     [800]byte // 数字，大端表示
	nd    int       // 使用的位数
	dp    int       // 小数点，注：小数点的位置，
	neg   bool      // 负数标志
	trunc bool      // 超过d[:nd]的非零数字，注：发生数据截断
}

func (a *decimal) String() string { //注：将a转为字符串并返回
	n := 10 + a.nd
	if a.dp > 0 {
		n += a.dp
	}
	if a.dp < 0 {
		n += -a.dp
	}

	buf := make([]byte, n)
	w := 0
	switch {
	case a.nd == 0:
		return "0"

	case a.dp <= 0:
		// 零填充小数点和数字之间的空间
		buf[w] = '0'
		w++
		buf[w] = '.'
		w++
		w += digitZero(buf[w : w+-a.dp]) //注：0.000
		w += copy(buf[w:], a.d[0:a.nd])  //注：0.000123
	case a.dp < a.nd:
		// 小数点中间的数字
		w += copy(buf[w:], a.d[0:a.dp]) //注：123
		buf[w] = '.'                    //注：123.
		w++
		w += copy(buf[w:], a.d[a.dp:a.nd]) //注：123.456

	default:
		// 零填充数字和小数点之间的空间
		w += copy(buf[w:], a.d[0:a.nd])      //注：123
		w += digitZero(buf[w : w+a.dp-a.nd]) //注：123000
	}
	return string(buf[0:w])
}

func digitZero(dst []byte) int { //注：将dst的每个元素赋值为0，返回元素长度
	for i := range dst {
		dst[i] = '0'
	}
	return len(dst)
}

// trim 从数字尾随零。
//（它们是没有意义的；小数点的跟踪与位数无关）。
func trim(a *decimal) {
	for a.nd > 0 && a.d[a.nd-1] == '0' { //注：去掉多余的前缀0（假如a=000123，nd=6，nd会减少为3，将多余的0去掉，但dp=6）
		a.nd--
	}
	if a.nd == 0 {
		a.dp = 0
	}
}

// Assign 将uint64转为decimal
func (a *decimal) Assign(v uint64) { //注：将v格式化为decimal赋值给a
	// buf[0]：3
	// buf[1]：2
	// buf[2]：1
	var buf [24]byte

	// 在buf中写反十进制。
	n := 0      //注：v的计量单位
	for v > 0 { //注：例：v=123
		v1 := v / 10 //注：v1=12，v1=1，v1=0
		v -= 10 * v1 //注：v=3，v=2，v=1
		buf[n] = byte(v + '0')
		n++
		v = v1 //注：v=12，v=1，v=0
	}

	// 再次反转以在a.d中产生正向小数。
	// a.d[0]：1
	// a.d[1]：2
	// a.d[2]：3
	a.nd = 0
	for n--; n >= 0; n-- {
		a.d[a.nd] = buf[n]
		a.nd++
	}
	a.dp = a.nd
	trim(a)
}

// 我们可以在一遍完成的最大移位，而不会发生溢出。
// 一个uint具有32或64位，我们必须能够容纳9 << k。
const uintSize = 32 << (^uint(0) >> 63) //注：uint的位数，与操作系统位数相同（32、64）
const maxShift = uintSize - 4           //注：执行Shift最大只能位移当前操作系统位数-4（28、60）

// 二进制右移（/ 2）k位。 k <= maxShift以避免溢出。
func rightShift(a *decimal, k uint) { //注：#
	r := 0 // 读指针
	w := 0 // 写指针

	// 拾取足够的前导数字以涵盖第一个shift。
	var n uint //注：k位a的暂存对象
	// 例：
	// a.d = 1234（0011 0001 0011 0010 0011 0011 0011 0100)
	// k = 8
	// a.nd = 4
	// mask = 1111 1111
	//
	// 以下代码遍历1次：r = 1，n = 1
	// 以下代码遍历2次：r = 2，n = 12（0011 0001 0011 0010)
	for ; n>>k == 0; r++ { //注：将a.d转为uint，长度为k
		if r >= a.nd { //注：遍历超过a的位数了也不会溢出k
			if n == 0 { //注：得出的值还是0的话，不应该发生，重新设置nd为0
				// a == 0; 不应该到这里，但还是要处理。
				a.nd = 0
				return
			}
			for n>>k == 0 { //注：a*=10直至超出k的偏移
				n = n * 10
				r++
			}
			break
		}
		c := uint(a.d[r]) //注：将ASCII编码转为uint
		n = n*10 + c - '0'
	}
	a.dp -= r - 1

	var mask uint = (1 << k) - 1 //注：掩码，用于获取k位数字

	// 拿起一个数字，放下一个数字。
	// 以下代码遍历1次： a.d[0] = 1，n = 23，r = 3，w = 1
	// 以下代码遍历2次： a.d[1] = 2，n = 34，r = 4，w = 2
	for ; r < a.nd; r++ { //注：获取最后k位数据
		c := uint(a.d[r])
		dig := n >> k //注：n超出k的1位
		n &= mask     //注：k位的n
		a.d[w] = byte(dig + '0')
		w++
		n = n*10 + c - '0'
	}

	// 放下多余的数字。
	// 以下代码遍历1次：a.d[2] = 3，n = 40，w = 3
	// 以下代码遍历1次：a.d[3] = 4，n = 0，w = 4
	for n > 0 {
		dig := n >> k
		n &= mask
		if w < len(a.d) {
			a.d[w] = byte(dig + '0')
			w++
		} else if dig > 0 { //注：根据例展示，如果a.d的字节数无法整除k（例如k = 7），可能会出现这个情况，形成数据截断
			a.trunc = true
		}
		n = n * 10
	}

	a.nd = w
	trim(a) //注：去除前缀0
}

// 左移位备忘单：该表由移位计数索引，给出了该移位将引入的新位数。
// 例如，leftcheats[4] = {2, "625"}。 这意味着如果我们<<4（乘以16），
// 则当字符串前缀为"625"至"999"时，它将加2位，如果字符串前缀为"000"至"624"，则将少一位。
// 归功于Ken。

type leftCheat struct {
	delta  int    // 新位数
	cutoff string // 如果original < a，则减去一位数字。
}

var leftcheats = []leftCheat{
	// 前导数字1/2^i = 5^i.
	// 5^23并不是确切的64位浮点数，因此必须使用bc进行数学运算。
	// 最多增加60个，足以容纳32位和64位平台。
	/*
		seq 60 | sed 's/^/5^/' | bc |
		awk 'BEGIN{ print "\t{ 0, \"\" }," }
		{
			log2 = log(2)/log(10)
			printf("\t{ %d, \"%s\" },\t// * %d\n",
				int(log2*NR+1), $0, 2**NR)
		}'
	*/
	{0, ""},
	{1, "5"},                                           // * 2
	{1, "25"},                                          // * 4
	{1, "125"},                                         // * 8
	{2, "625"},                                         // * 16
	{2, "3125"},                                        // * 32
	{2, "15625"},                                       // * 64
	{3, "78125"},                                       // * 128
	{3, "390625"},                                      // * 256
	{3, "1953125"},                                     // * 512
	{4, "9765625"},                                     // * 1024
	{4, "48828125"},                                    // * 2048
	{4, "244140625"},                                   // * 4096
	{4, "1220703125"},                                  // * 8192
	{5, "6103515625"},                                  // * 16384
	{5, "30517578125"},                                 // * 32768
	{5, "152587890625"},                                // * 65536
	{6, "762939453125"},                                // * 131072
	{6, "3814697265625"},                               // * 262144
	{6, "19073486328125"},                              // * 524288
	{7, "95367431640625"},                              // * 1048576
	{7, "476837158203125"},                             // * 2097152
	{7, "2384185791015625"},                            // * 4194304
	{7, "11920928955078125"},                           // * 8388608
	{8, "59604644775390625"},                           // * 16777216
	{8, "298023223876953125"},                          // * 33554432
	{8, "1490116119384765625"},                         // * 67108864
	{9, "7450580596923828125"},                         // * 134217728
	{9, "37252902984619140625"},                        // * 268435456
	{9, "186264514923095703125"},                       // * 536870912
	{10, "931322574615478515625"},                      // * 1073741824
	{10, "4656612873077392578125"},                     // * 2147483648
	{10, "23283064365386962890625"},                    // * 4294967296
	{10, "116415321826934814453125"},                   // * 8589934592
	{11, "582076609134674072265625"},                   // * 17179869184
	{11, "2910383045673370361328125"},                  // * 34359738368
	{11, "14551915228366851806640625"},                 // * 68719476736
	{12, "72759576141834259033203125"},                 // * 137438953472
	{12, "363797880709171295166015625"},                // * 274877906944
	{12, "1818989403545856475830078125"},               // * 549755813888
	{13, "9094947017729282379150390625"},               // * 1099511627776
	{13, "45474735088646411895751953125"},              // * 2199023255552
	{13, "227373675443232059478759765625"},             // * 4398046511104
	{13, "1136868377216160297393798828125"},            // * 8796093022208
	{14, "5684341886080801486968994140625"},            // * 17592186044416
	{14, "28421709430404007434844970703125"},           // * 35184372088832
	{14, "142108547152020037174224853515625"},          // * 70368744177664
	{15, "710542735760100185871124267578125"},          // * 140737488355328
	{15, "3552713678800500929355621337890625"},         // * 281474976710656
	{15, "17763568394002504646778106689453125"},        // * 562949953421312
	{16, "88817841970012523233890533447265625"},        // * 1125899906842624
	{16, "444089209850062616169452667236328125"},       // * 2251799813685248
	{16, "2220446049250313080847263336181640625"},      // * 4503599627370496
	{16, "11102230246251565404236316680908203125"},     // * 9007199254740992
	{17, "55511151231257827021181583404541015625"},     // * 18014398509481984
	{17, "277555756156289135105907917022705078125"},    // * 36028797018963968
	{17, "1387778780781445675529539585113525390625"},   // * 72057594037927936
	{18, "6938893903907228377647697925567626953125"},   // * 144115188075855872
	{18, "34694469519536141888238489627838134765625"},  // * 288230376151711744
	{18, "173472347597680709441192448139190673828125"}, // * 576460752303423488
	{19, "867361737988403547205962240695953369140625"}, // * 1152921504606846976
}

// 在字典上b的前导前缀是否小于s？
func prefixIsLessThan(b []byte, s string) bool { //注：返回s转为数字是否大于b转为数字
	for i := 0; i < len(s); i++ {
		if i >= len(b) {
			return true
		}
		if b[i] != s[i] {
			return b[i] < s[i]
		}
	}
	return false
}

// 二进制左移（* 2）k位。 k <= maxShift以避免溢出。
func leftShift(a *decimal, k uint) {
	// 例：
	// a.d = 1234（0011 0001 0011 0010 0011 0011 0011 0100)
	// k = 8
	// a.nd = 4
	// r = 4
	// w = 7

	delta := leftcheats[k].delta
	//注："390625" > "825373492"
	if prefixIsLessThan(a.d[0:a.nd], leftcheats[k].cutoff) { //注：如果leftcheats > a
		delta--
	}

	r := a.nd         // 读索引
	w := a.nd + delta // 写索引

	// 拿起一个数字，放下一个数字。
	var n uint
	// 注：以下代码遍历1次：n = 256，quo = 25， rem = 6
	for r--; r >= 0; r-- {
		n += (uint(a.d[r]) - '0') << k
		quo := n / 10
		rem := n - 10*quo
		w--
		if w < len(a.d) {
			a.d[w] = byte(rem + '0')
		} else if rem != 0 {
			a.trunc = true
		}
		n = quo
	}

	// Put down extra digits.
	for n > 0 {
		quo := n / 10
		rem := n - 10*quo
		w--
		if w < len(a.d) {
			a.d[w] = byte(rem + '0')
		} else if rem != 0 {
			a.trunc = true
		}
		n = quo
	}

	a.nd += delta
	if a.nd >= len(a.d) {
		a.nd = len(a.d)
	}
	a.dp += delta
	trim(a)
}

// 向左（k > 0）或向右（k < 0）的二进制移位。
func (a *decimal) Shift(k int) { //注：将a根据k是否为正数进行左移或右移，如果移动超过了最大移动限制，则移动多次
	switch {
	case a.nd == 0:
		// 无事可做：a == 0
	case k > 0:
		for k > maxShift {
			leftShift(a, maxShift)
			k -= maxShift
		}
		leftShift(a, uint(k))
	case k < 0:
		for k < -maxShift {
			rightShift(a, maxShift)
			k += maxShift
		}
		rightShift(a, uint(-k))
	}
}

// 如果我们将数字位数切成小数，应该舍入吗？
func shouldRoundUp(a *decimal, nd int) bool { //注：判断a保留小数点nd位是舍还是入（四舍六入五成双）
	// 例1：如果a.d = 12345，a.nd = 5，nd = 3
	// a.d[3] = 4 != 5，返回false
	//
	// 例1：如果a.d = 12345，a.nd = 5，nd = 4
	// a.d[4] = 5 == 5，且4 + 1 == 5，如果截断过数据（a.nd后被忽略了一些精度）返回true，否则a.d[nd-1]为单数返回true，为双数返回false
	if nd < 0 || nd >= a.nd {
		return false
	}
	if a.d[nd] == '5' && nd+1 == a.nd { // 正好中途-舍入到偶数
		// 如果我们将其截断，则比记录的要高一些-总是四舍五入
		if a.trunc {
			return true
		}
		return nd > 0 && (a.d[nd-1]-'0')%2 != 0
	}
	// 不是半途而废-数字可以说明一切
	return a.d[nd] >= '5'
}

// Round a至nd位（或更少）。
// 如果nd为零，则表示我们将舍入到数字的左边，如0.09 -> 0.1。
func (a *decimal) Round(nd int) { //注：保留a的小数精确到nd位（四舍六入五成双）
	if nd < 0 || nd >= a.nd {
		return
	}
	if shouldRoundUp(a, nd) {
		a.RoundUp(nd)
	} else {
		a.RoundDown(nd)
	}
}

// 向下舍入到nd位（或更少）。
func (a *decimal) RoundDown(nd int) { //注：a向下去舍到nd位
	if nd < 0 || nd >= a.nd {
		return
	}
	a.nd = nd //注：向下去舍直接设置a.nd
	trim(a)
}

// 四舍五入至nd位数（或更少）。
func (a *decimal) RoundUp(nd int) { //注：a向上去舍到nd位
	if nd < 0 || nd >= a.nd {
		return
	}

	// 例1：a = 12345，a.nd = 5，执行a.RoundUp(3)
	// a = 12445，a.nd = 3
	//
	// 例2：a = 12945，a.nd = 5，执行a.RoundUp(3)
	// 以下代码循环第1次：a = 12945，i = 1
	// 以下代码循环第1次：a = 13945，i = 1，a.nd = 2
	// 向上取舍
	for i := nd - 1; i >= 0; i-- {
		c := a.d[i]
		if c < '9' { //可以在此数字之后停止
			a.d[i]++
			a.nd = i + 1
			return
		}
	}

	// 数字全为9。
	// 将小数点调整为1。
	a.d[0] = '1'
	a.nd = 1
	a.dp++
}

// 提取整数部分，适当舍入。
// 不保证溢出。
func (a *decimal) RoundedInteger() uint64 { //注：获取a的整数，小数部分四舍五入（四舍六入五成双）
	if a.dp > 20 { //注：如果是20位以上整数，返回最大值
		return 0xFFFFFFFFFFFFFFFF
	}
	var i int
	n := uint64(0)
	// 例： a.d = 12345.678
	// n = 12345
	for i = 0; i < a.dp && i < a.nd; i++ {
		n = n*10 + uint64(a.d[i]-'0')
	}
	for ; i < a.dp; i++ { //注：如果a.d = 123，a.dp = 5，n为12300
		n *= 10
	}
	if shouldRoundUp(a, a.dp) { //注：如果a保留小数位数a.dp位进位时，a的整数+1
		n++
	}
	return n
}
